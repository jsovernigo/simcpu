*************************************************
Julian Sovernigo            0948924
gsoverni@mail.uoguelph.ca
CIS3110_W17                 A1: basic shell
1/30/2017
*************************************************

******************
Pledge of Honesty
******************
    By handing in this assignment with this README file, I
assert that I have sole access and control over my submission,
and that this submission contains entirely my own work. I
affirm that I have not colaborated in the creation of this code,
nor have I taken any segment of code that I do not have express
ownership or permission to use.

************
Compilation
************

1- cd to the root folder of the program
2- type 'make' in the root folder.
3- to remove resources generated by compilation, please type 'make clean'

********************
Running the program
********************

1- cd to the root folder of the program
2- use ./jsh to run it
3- the proram is a shell, unix commands are used.

****
???
****

Command:		multiplication
Inputs:			0x12, 10, 15, etc.
Outputs:		the product of the (numeric) arguments given.

********************
Program Description
********************

	The program's algorith follows the following proceedure:

	First, the program enters a do-while loop; essentially, the loop waits
until a valid quit command has been entered.  The loop then prompts the user
with a traditional ~$ for a command.  Upon receiving a command, the arguments
will be checked for special characters, like the &, or an in/out redirect.
Once all of these things have been checked, and the final arguments are constructed
(special terms and file names are removed...), we fork, and pass off execution to
the child process.

	The child process will examine the actual arguments further, and will first
check wether the any streams were redirected, and then handle them in the child 
process.  Next, the commands are checked if they are shell-implimented, or a 
predefined one that is handled by the OS.  If it is shell implimented, the shell
will send the args over to the function associated with it in the driver.c file.
If the command is NOT a shell-implimented one, then the commands themselves are
sent off to the OS through the use of the execvp() function call.  Once the OS
returns (or we are done executing our own commands), the child process will exit.

	In the parent process, the forked pid is added to an array of pids that are
kept in order to prevent zombie-creation later.  Once the pid is recorded, the 
program will determine if nowait has been set, indicating a background process.
If nowait is set to zero, however, this indicates a foreground process, so we
need to wait for the process to finish.  This is done using the waitpid command,
which allows us to limit our waiting to the single process that we forked in the
forground.

	If the fork() call returns an invalid pid, which would represent a failed 
fork attempt, then a message is printed to the screen to alert the user, but the 
shell will continue to execute.

	Finally, once the user has entered the quit command, the program will exit
from the main body loop that was used to get user commands (and for for their
subsequent execution). Outside the main loop, a cleanup process will loop through
the stored pid we have been keeping track of this whole time, and send a SIGTERM
command to each of them, so that they do not keep executing in the background if
they did not have a finite stop condition, or are depending on some other event.
But, because the OS guarantees non-reuse of PIDs, there is no need for checking
the status or ownership of the pids that are executing. Upon cleaning up the 
processes in the background, the program finally returns 0.
