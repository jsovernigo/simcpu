*************************************************
Julian Sovernigo            0948924
gsoverni@mail.uoguelph.ca
CIS3110_W17                 A1: thread scheduler
2/27/2017
*************************************************

******************
Pledge of Honesty
******************
    By handing in this assignment with this README file, I
assert that I have sole access and control over my submission,
and that this submission contains entirely my own work. I
affirm that I have not colaborated in the creation of this code,
nor have I taken any segment of code that I do not have express
ownership or permission to use.

************
Compilation
************

1- cd to the root folder of the program
2- type 'make' in the root folder.
3- to remove resources generated by compilation, please type 'make clean'

********************
Running the program
********************

1- cd to the root folder of the program
2- use ./simcpu to run it
3- flags:
	[-d]			- runs in detailed mode
	[-v]			- runs in verbose mode
	[-r][<quantum>]	- runs in round robin mode, quantum must be supplied.

********************
Program Description
********************

	The program's algorith follows the following proceedure:

	The sceduler operates in two different modes, fcfs, and RR.  In FCFS mode,
the threads are first read in and placed into a "future events" queue.  These
are then read, one by one, with time-ties being resolved using a "file-original-
order" method.  In otherwords, if two threads arrive at the same time, then the
one specified first in the file is the one placed in the ready queue first. The
threads are read into the ready queue, with each one being given a blank com-
pletion record, which is updated as the simulation continues.  In Round Robin
mode, the events are similarly read into a queue fo future events, then trans-
ferred into the ready queue when the arrive, but this time, instead of events
bing given a blank completion record and being allowed to run until completion,
the thread runs until the quantum expires, and is then stores its record, a new
thread is loaded, and its record is retreived or created.  The final records,
printed using the -d flag, are given in the order they arrive in at the scheduler
(again, another queue is used, simply to preserve ordering.)

	While running the simulation, several types of overhead are expressed:

	When first beginning the run, overhead is added when loading a starting thread.
It is assumed that this thead is the most distant possible, and so accounts for
thread AND process context switch on the initial load.  When switching to a thread
of the same process, the scheduler adds the thread delay to the "busy" counter,
which is counted down until the process can begin execution.  When switching to
a thread in a different process, both the thread and process delays are added
to the busy counter, since we are transitioning between both types of boundaries.

	Note however, that since a thread is NOT unloaded and reloaded when the ready
queue is empty, that the delay is not registered here, because the thread is never
actually taken out of running mode.  Also, no overhead is associated with time
slice interrupts, and as such should not be expected in the output.
